# README: Goal Tracker Feature Upgrades (April 2024)

## Overview

This update includes several important feature enhancements and bug fixes for the Goal Tracker application, aimed at improving user experience, increasing data accuracy, and introducing intelligent analysis. The main updates include: completely fixing the Daily Task checkbox status saving issue, integrating AI progress analysis functionality based on Hugging Face, adding PDF export capability, and adjusting the page layout.

## Major Changes and Features

### 1. Daily Task Status Saving Restructuring

*   **Problem**: The issue previously encountered by users where Daily Task checkbox states could not be correctly persisted (especially status loss after clicking "Save Changes") has been thoroughly resolved.
*   **Fixes**:
    *   **Simplified API Calls**: Removed redundant API save calls, unifying the responsibility for immediate status saving (`handleTaskStatusChange`) and final saving (`handleSave`) to the `DailyCardRecord` component.
    *   **Fixed Callback Data**: Ensured consistent data format for the `onSave` callback in different saving scenarios (individual checkbox vs. clicking Save Changes), passing a single updated card object.
    *   **Enforced Deep Copying**: Extensively used `JSON.parse(JSON.stringify(...))` for deep copying when passing state (`cardData`, `dailyCards`) between components and updating internal state (`taskCompletions`), completely resolving state override and update inconsistency issues caused by object references.
    *   **Initialization Fix**: Ensured correct initialization of the `taskCompletions: {}` field when creating card data for new dates in the `WeeklyDailyCards` component.
    *   **Date Validation Improvement**: Corrected the `validateCardData` function to ensure key states like `taskCompletions` of the original card are preserved when handling invalid or missing dates.
*   **Files Involved**: `client/src/components/GoalDetails/*`, `server/controllers/goalsController.js`

### 2. AI Progress Analysis Integration

*   **New Feature**: Added "AI Progress Analysis" functionality in the Progress Report area. Users can click the "Generate Analysis" button to receive an analysis and suggestions generated by an AI model based on recent goal progress (read from Daily Cards).
*   **Implementation**:
    *   **Backend**:
        *   Created a new API route (`server/routes/reports.js`) to handle `POST /api/reports/:goalId` requests.
        *   Created a new controller (`server/controllers/reportsController.js`) containing core logic:
            *   `generateReport`: Gets the `goalId`, queries Goal data from the database.
            *   `buildPrompt`: Constructs a structured prompt based on Goal description, Daily Tasks, and recent Daily Cards (task completion status, progress records).
            *   `callAIService`: Uses `axios` to call the external Hugging Face Inference API, sending the prompt and retrieving AI-generated text.
        *   Requires environment variables (see below) to specify the Hugging Face API Token and model URL.
        *   Requires installing `axios` and `dotenv` dependencies (`npm install axios dotenv -C server`).
    *   **Frontend**:
        *   Created the `AIFeedback.jsx` component (`client/src/components/ProgressReport/`), including a "Generate Analysis" button, loading state, error display, and display of the AI-returned `feedback.content`.
        *   Added a service in `api.js` to call the backend report generation API.
*   **Prompt Optimization**: Iterated on the prompt sent to the AI, explicitly requesting output to include "Progress Analysis", "Potential Challenges", "Actionable Suggestions" sections, and instructing the AI not to generate irrelevant content like "Key Achievements".

### 3. PDF Export Feature

*   **New Feature**: Added an "Export PDF" button in the Progress Report area.
*   **Implementation**:
    *   Uses client-side libraries `html2canvas` and `jspdf`.
    *   `ExportButton.jsx` (`client/src/components/ProgressReport/`) contains the `handleExport` logic:
        *   Uses `html2canvas` to capture the `.main-content` area DOM element, generating a Canvas image.
        *   Uses `jspdf` to add the Canvas image to a PDF document.
        *   Automatically handles content pagination.
        *   Triggers browser download of a file named `GoalProgressReport.pdf`.
    *   Requires installing dependencies (`npm install html2canvas jspdf -C client`).

### 4. Page Layout Adjustment (Flexbox)

*   **Modification**: Adjusted the CSS styles of the main content area (`.main-content`) in `Home.jsx` page (`client/src/styles/Home.css`).
*   **Effect**: Used Flexbox to implement a fixed 1:2:1 width ratio layout for the Sidebar, GoalDetails, and ProgressReport areas, ensuring each area can scroll independently when content overflows.

### 5. Component Removal

*   **Removal**: Deleted the no longer needed `KeyAchievements.jsx` component and its references in `ProgressReport.jsx`.

## Hugging Face AI Configuration Guide

To make the AI progress analysis functionality work properly, you need to configure the Hugging Face Inference API.

**Why use Hugging Face?**
Hugging Face provides a large number of pre-trained AI models, and its Inference API allows us to call these models for free (within certain limits) without having to deploy and manage them ourselves.

**Configuration Steps:**

1.  **Choose a model**:
    *   Visit [Hugging Face Models](https://huggingface.co/models).
    *   Select a model suitable for text generation or instruction following. **Strongly recommend** using Instruction-Tuned models, which are better at understanding and executing our prompts.
    *   **Recommended model**: `mistralai/Mistral-7B-Instruct-v0.2` (good performance, relatively fast response).
    *   **Alternative models**: `meta-llama/Llama-2-7b-chat-hf` (strong performance, but may be slightly slower). You can try other models, but make sure they are compatible with the request/response format in our code.

2.  **Find the model's Inference API URL**:
    *   Search for your chosen model name on the Hugging Face website.
    *   Enter the model's page.
    *   Click the "Deploy" or "Use" button/dropdown on the page.
    *   Select the "Inference API" option.
    *   You will see the API URL for that model. **Copy this complete URL**.
        *   *For example, for `mistralai/Mistral-7B-Instruct-v0.2`, the URL is `https://api-inference.huggingface.co/models/mistralai/Mistral-7B-Instruct-v0.2`*

3.  **Create a Hugging Face Access Token**:
    *   Log in to the Hugging Face website.
    *   Click your avatar (top right corner), select "Settings".
    *   Select "Access Tokens" from the left menu.
    *   Click the "New token" button.
    *   **Token name**: Enter a descriptive name, like `GoalTrackerApp`.
    *   **Role**: Select **`Read`**. Read permission is sufficient to call the Inference API.
    *   Click "Generate a token".
    *   **Important**: Hugging Face will **show once** the newly generated Token value (starting with `hf_`). **Immediately copy this complete Token** and save it securely. You will not be able to see the complete Token again after leaving this page.

4.  **Configure the `.env` file (backend)**:
    *   In your project **backend** directory (`server/`), find or create a file named `.env`.
    *   Open the `.env` file, add or modify the following two lines, pasting in your copied Token and URL:
        ```env
        # server/.env
        HUGGINGFACE_API_TOKEN=hf_YOUR_COPIED_TOKEN_HERE
        HUGGINGFACE_API_URL=YOUR_COPIED_MODEL_API_URL_HERE
        ```
        *Example:*
        ```env
        HUGGINGFACE_API_TOKEN=hf_abc123xyz...
        HUGGINGFACE_API_URL=https://api-inference.huggingface.co/models/mistralai/Mistral-7B-Instruct-v0.2
        ```
    *   **Security tip**: The `.env` file contains sensitive information, **never** commit it to Git or other version control systems. Make sure your `.gitignore` file (typically in the project root or `server` directory) includes the `.env` line.

5.  **Install backend dependencies (if not already installed)**:
    *   Make sure your backend has `axios` (for API calls) and `dotenv` (for loading the `.env` file) installed. Run in the `server` directory:
        ```bash
        npm install axios dotenv
        ```

6.  **Restart the backend server**:
    *   **Very important**: After modifying the `.env` file, you must **completely stop** (press `Ctrl+C` in the terminal) and **restart** your backend development server (`npm run dev`), so the new environment variables can be loaded by the Node.js process.

After completing these steps, your AI progress analysis feature should be able to connect to Hugging Face and try to generate feedback.

## PDF Export Dependencies

Make sure your **frontend** project (`client/`) has the necessary libraries installed:

```bash
npm install html2canvas jspdf
```

## Troubleshooting

*   **AI functionality error `503 Service Unavailable`**: Usually means the Hugging Face model is loading (especially after the first call or after a long period of inactivity). Please wait a few minutes and try again. If it persists, check the Hugging Face model page for status updates, or try changing the model URL.
*   **AI functionality error `401 Unauthorized` / "Authentication Failed"**: Please carefully check if the `HUGGINGFACE_API_TOKEN` in your `server/.env` file matches exactly what you copied from Hugging Face, then restart the server.
*   **AI functionality error `404 Not Found`**: Please carefully check if the `HUGGINGFACE_API_URL` in your `server/.env` file is the correct **Inference API URL** for your chosen model, then restart the server.
*   **Poor AI output quality/messy format**:
    *   Try adjusting the instructions in the `buildPrompt` function in `server/controllers/reportsController.js`. Prompt Engineering is an iterative process.
    *   Try switching to a stronger AI model or one better suited for instruction following (don't forget to update the `.env` file and restart).
    *   Check if the logic for parsing API responses in the `callAIService` function matches the data structure returned by the selected model (look at "AI service raw response data" in the server logs).
*   **PDF export fails/blank/missing styles**:
    *   Check the browser console for `html2canvas` or `jsPDF` related errors.
    *   Make sure `document.querySelector('.main-content')` in `ExportButton.jsx` correctly selects the HTML container you want to export.
    *   Complex CSS (like certain Flexbox/Grid layouts, pseudo-elements, external fonts) may not be perfectly captured by `html2canvas`.

## Date Filtering Feature (May 2024 Update)

### Feature Overview

To increase the flexibility and accuracy of the AI progress analysis functionality, we've added date range filtering, allowing users to select specific time periods for analysis.

### Major Updates

*   **Time Range Selector**:
    *   Added a time range selection dropdown menu in the "AI Progress Analysis" component
    *   Preset options include "Last 7 days" (default), "Last 30 days", and "Custom Range"
    *   When "Custom Range" is selected, a date picker dialog appears, allowing users to precisely select start and end dates

*   **Frontend Implementation**:
    *   Enhanced the `AIFeedback.jsx` component with date selection and handling logic
    *   Added `LocalizationProvider` and `DatePicker` components for date selection
    *   Updated the API call to pass the selected date range to the backend
    *   Displayed the selected time range information in the generated report

*   **Backend Implementation**:
    *   Modified the `generateReport` function in `reportsController.js` to accept time range parameters
    *   Updated the database query logic to only retrieve Daily Cards within the specified date range
    *   Improved the `buildPrompt` function to include the date range in the prompt, making the AI generate more targeted analysis

### Dependency Installation

To use this feature, the following additional dependencies need to be installed:

```bash
npm install @mui/x-date-pickers date-fns
```

### Usage Instructions

1.  In the "AI Progress Analysis" component, use the time range dropdown menu to select the desired analysis period
2.  When selecting "Custom Range", set precise start and end dates in the popup dialog
3.  Click the "Generate Analysis" button, and the system will only generate analysis based on records within the selected time range

### Notes

*   If there is no data within the selected time range, the AI will generate analysis based on limited information and may prompt that data is insufficient
*   For best analysis results, it's recommended to select a time range with enough data points (at least 3-5 days)
*   Excessively long time ranges may lead to less focused analysis; it's advisable to choose an appropriate time window based on goal characteristics

## Goal Switching AI Analysis Report Retention Plan (May 2024 Update)

### Problem Description

Currently, when users switch between different goals, the AI analysis report is not retained. Each time they switch goals, they need to click the "Generate Analysis" button again, resulting in a discontinuous user experience, especially for goals that have already had analysis generated, which should be immediately visible.

### Solution: Using Zustand for Global State Management

We will use Zustand for global state management to cache generated AI analysis reports for each goal. This way, when switching between goals, previously generated reports can be displayed immediately, improving user experience.

#### 1. Designing the Zustand Store

```javascript
// Pseudocode: Define Zustand store
import create from 'zustand';

const useReportStore = create((set) => ({
  // For storing AI analysis reports for each goal
  reports: {}, // Structure: { goalId1: { content, generatedAt, dateRange }, goalId2: {...}, ... }

  // Set report for a specific goal
  setReport: (goalId, reportData) => 
    set((state) => ({
      reports: {
        ...state.reports,
        [goalId]: reportData
      }
    })),
    
  // Get report for a specific goal
  getReport: (goalId) => useReportStore.getState().reports[goalId] || null,
  
  // Clear all reports (optional, for reset or logout)
  clearReports: () => set({ reports: {} })
}));
```

#### 2. Integration Plan

1. **Install Dependencies**:
   ```bash
   npm install zustand
   ```

2. **Create Store**:
   - Create `reportStore.js` file in the `src/store` directory
   - Implement the Zustand store logic described above
   - Add necessary type definitions (if using TypeScript)

3. **Update AIFeedback Component**:
   - Import the Zustand store
   - Read from and store reports in the store
   - Automatically load existing reports based on goalId changes
   - Update the store when generating new reports

4. **Optimize Data Flow**:
   - When component loads, first check if the store has a report for that goal
   - If yes, display immediately
   - If no, show the "Generate Analysis" button
   - After clicking "Generate Analysis", save the new report to the store

#### 3. Implementation Code Structure

**`reportStore.js`**:
```javascript
import create from 'zustand';
import { persist } from 'zustand/middleware';

// Use persist middleware, optionally choose whether to preserve data after browser refresh
export const useReportStore = create(
  persist(
    (set, get) => ({
      reports: {},
      setReport: (goalId, reportData) => 
        set((state) => ({
          reports: {
            ...state.reports,
            [goalId]: {
              ...reportData,
              generatedAt: new Date().toISOString(),
              dateRange: {
                startDate: reportData.startDate || new Date().toISOString(),
                endDate: reportData.endDate || new Date().toISOString()
              }
            }
          }
        })),
      getReport: (goalId) => get().reports[goalId] || null,
      clearReports: () => set({ reports: {} })
    }),
    {
      name: 'ai-reports-storage',
      partialize: (state) => ({ reports: state.reports })
    }
  )
);
```

**`AIFeedback.jsx` Core Logic Update**:
```javascript
// Pseudocode: Changes in AIFeedback component
import { useReportStore } from '../../store/reportStore';

export default function AIFeedback({ goalId }) {
  // ... existing code

  // Use Zustand store
  const { reports, setReport, getReport } = useReportStore();
  
  // Get report for current goal
  const currentReport = goalId ? reports[goalId] : null;
  
  // Use useEffect to update state when goalId changes
  useEffect(() => {
    if (goalId && reports[goalId]) {
      setFeedback(reports[goalId]);
      setLastUpdate(new Date(reports[goalId].generatedAt));
      setStartDate(new Date(reports[goalId].dateRange.startDate));
      setEndDate(new Date(reports[goalId].dateRange.endDate));
    } else {
      // Reset state
      setFeedback(null);
      setLastUpdate(null);
    }
  }, [goalId, reports]);
  
  // Modify generateFeedback function, add saving to Zustand
  const generateFeedback = async () => {
    // ... existing generation logic
    
    try {
      // ... API call
      
      if (response.data && response.data.success) {
        const reportData = response.data.data;
        setFeedback(reportData);
        setLastUpdate(new Date());
        
        // Save to Zustand
        setReport(goalId, reportData);
      }
    } catch (err) {
      // ... error handling
    }
  };
  
  // ... rendering logic
}
```

#### 4. Optional Extended Features

1. **Timed Update Strategy**:
   - Add timestamps to stored reports
   - Automatically prompt users to regenerate if reports are older than a certain time (e.g., 24 hours)

2. **Batch Preloading**:
   - Automatically pre-generate reports for frequently accessed goals during user idle time
   - Use Web Workers or low-priority tasks to avoid impacting the main thread

3. **Export/Import Functionality**:
   - Allow users to export all AI analysis reports
   - Import report data on new devices

### Technical Considerations

1. **Performance Impact**: 
   - Zustand as a lightweight state management library has minimal performance impact
   - The stored data volume is relatively small and won't cause noticeable memory pressure

2. **Trade-off Analysis**:
   - **Advantages**: Greatly improves user experience, reduces repetitive API calls, saves server resources
   - **Disadvantages**: Increases code complexity, requires handling state synchronization issues

3. **Alternative Options**:
   - **Direct LocalStorage Storage**: Simple but difficult to keep synchronized with component state
   - **Context API**: Built-in React feature, but weaker support for complex state updates
   - **Redux**: Powerful but relatively complex, may be overkill for this scenario
   - **MobX**: Better reactivity, but steeper learning curve

### Implementation Plan

1. **Phase 1**: Create basic Zustand store, implement single goal report storage and retrieval
2. **Phase 2**: Improve error handling, add data expiration strategy
3. **Phase 3**: Performance optimization and edge case handling
4. **Testing**: Focus on report retention and display when switching goals

### Summary

By introducing Zustand for state management, we can effectively solve the issue of AI analysis report loss when switching goals, improving user experience while reducing unnecessary API calls and conserving server resources. This improvement will make the AI analysis feature more practical and user-friendly.

## Precise Export of Specific Content Areas Plan (May 2024 Update)

### Feature Requirements

The current export functionality generates a PDF report containing the entire page, but sometimes users may only want to export specific content areas. In particular, there is a need to selectively export:

1. **AI Analysis Report Content**:
   ```
   #root > div > div > div._reportContainer_hyxpf_2 > div > div.ai-feedback-content.MuiBox-root.css-0
   ```

2. **Goal Declaration Content**:
   ```
   body > div.MuiDialog-root.MuiModal-root.css-1424xw8-MuiModal-root-MuiDialog-root > div.MuiDialog-container.MuiDialog-scrollPaper.css-19do60a-MuiDialog-container > div > div > div._contentContainer_1iu46_46
   ```

### Implementation Approach

We can extend the existing export functionality to add the ability to selectively export specific content:

1. **Modify the ExportButton Component**:
   - Add a dropdown menu with different export options
   - Options include: "Complete Report", "AI Analysis Only", "Goal Declaration Only"

2. **Selective Content Capture**:
   - Based on user selection, use document.querySelector to get specific DOM elements
   - Use precise CSS selectors to target content
   - Only pass the selected content area to html2canvas for capture

3. **Improve PDF Generation Logic**:
   - Adjust PDF page settings based on content type (such as page size, orientation, etc.)
   - Add appropriate titles and headers for different content types
   - Improve style handling to ensure the exported content looks attractive

### User Interface Design

The export button will be expanded into a dropdown menu format:

```
Export ▼
  ├─ Complete Report
  ├─ AI Analysis Only
  └─ Goal Declaration Only
```

### Technical Considerations

1. **DOM Selectors**:
   - Precise CSS selectors may be sensitive to future UI changes
   - Consider adding specific data-export-id attributes to key elements to enhance selector stability

2. **Asynchronous Export Processing**:
   - For goal declarations, need to ensure the dialog is open and content is loaded
   - Consider adding waiting logic or callback functions to ensure content is available

3. **Style Preservation**:
   - Ensure html2canvas can correctly capture all styles, including custom fonts, colors, etc.
   - May need to optimize certain CSS styles specifically for export

### Future Extensions

After implementing this feature, further considerations include:

1. Allow users to choose multiple content areas to combine for export
2. Provide different export formats (PDF, image, text, etc.)
3. Add custom export options, allowing users to select any area on the page for export

### Implementation Priority

Recommended implementation order:
1. First implement selective export of AI analysis reports
2. Then add goal declaration export functionality
3. Finally optimize user interface and style handling

## Features that Yan-Bo Implements (April 2025 Update)

### 1. Goal Switching AI Analysis Report Retention Feature

Successfully implemented the Zustand state management to ensure AI analysis reports are retained when switching between different goals, as outlined in the plan.

**Implementation Details**:
- Created Zustand state store for caching AI analysis reports for different goals
- Integrated state management in the AIFeedback component, implementing automatic loading and saving of reports
- Optimized user experience, eliminating the need to regenerate analysis reports every time goals are switched

**Technical Details**:
```javascript
// reportStore.js
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export const useReportStore = create(
  persist(
    (set, get) => ({
      reports: {},
      setReport: (goalId, reportData) => 
        set((state) => ({
          reports: {
            ...state.reports,
            [goalId]: {
              ...reportData,
              generatedAt: new Date().toISOString(),
              dateRange: {
                startDate: reportData.startDate || new Date().toISOString(),
                endDate: reportData.endDate || new Date().toISOString()
              }
            }
          }
        })),
      getReport: (goalId) => get().reports[goalId] || null,
      clearReports: () => set({ reports: {} })
    }),
    {
      name: 'ai-reports-storage',
      partialize: (state) => ({ reports: state.reports })
    }
  )
);
```

### 2. Precise Export of Specific Content Areas Feature

Implemented targeted PDF export functionality for specific content areas, capable of exporting both AI analysis reports and goal declarations.

**Implementation Details**:
- Restructured the ExportButton component, adding the ability to capture specific content areas
- Used data-export-id attributes to mark content for export, improving selector stability
- Added special logic for handling goal declaration content in modal dialogs
- Optimized PDF format and layout, adding appropriate titles and headers for different content

**Main Implementation Code**:
```javascript
// Content area marking
<Box className="ai-feedback-content" data-export-id="ai-analysis-content">
  {feedback.content || 'No analysis content'}
</Box>

<div className={styles.contentContainer} data-export-id="goal-declaration-content">
  {/* Goal declaration content */}
</div>

// Export logic in ExportButton.jsx
const handleExport = async () => {
  try {
    setExporting(true);
    
    // Allow time for goal declaration dialog to open
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Initialize PDF
    const pdf = new jsPDF('p', 'pt', 'a4');
    
    // Capture AI analysis report content
    const aiAnalysisElement = document.querySelector('[data-export-id="ai-analysis-content"]');
    if (aiAnalysisElement) {
      // Use text extraction method to add content to PDF
      const textContent = aiAnalysisElement.textContent;
      // ...add content to PDF
    }
    
    // Capture goal declaration content
    const declarationElement = document.querySelector('[data-export-id="goal-declaration-content"]');
    if (declarationElement) {
      // ...add content to PDF
    }
    
    // Save PDF
    pdf.save('GoalReport.pdf');
  } catch (err) {
    console.error("Error during PDF export:", err);
  } finally {
    setExporting(false);
  }
};
```

### 3. Export Feature Enhancement and Optimization

Made multiple enhancements and optimizations to the export functionality, improving user experience and export content quality.

**Improvements**:
- Added loading state display during export
- Enhanced error handling, providing more detailed error feedback
- Optimized content capture logic, supporting both text mode and image mode dual capture
- Added detailed debug logs for easier problem diagnosis

**Key Techniques**:
- Using async/await and Promises to handle asynchronous operations
- Using text extraction as a fallback for html2canvas
- Precise control of PDF page layout, including pagination, headers, and footers

### Summary

Through these implementations, we've successfully solved the following issues:
1. AI analysis report loss when switching goals
2. Precise capture of specific content areas rather than the entire page
3. Handling the special case of goal declaration content in modal dialogs
4. Improving the quality and accuracy of exported content

These feature implementations have greatly enhanced the application's user experience, particularly in terms of report generation and export efficiency.
